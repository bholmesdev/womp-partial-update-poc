---
export const partial = true;

import { z } from "astro/zod";
import { Card, CardHeader, CardContent } from "../../components/card";
import { EncodeProps, resolveProps } from "@/utils.tsx";

type Props = {
  id: string;
  name: string;
};

const { id, name: initialName } = await resolveProps(Astro);

let fieldErrors: { id?: string[]; name?: string[] } = {};
let name = initialName;
let success = false;

if (Astro.request.method === "POST") await handlePost();

async function handlePost() {
  const request = Astro.request.clone();
  const formData = await request.formData();
  if (formData.get("type") !== id) return;

  const obj = Object.fromEntries(formData.entries());
  const parsed = z.object({ name: z.string().min(2) }).safeParse(obj);

  if (!parsed.success) {
    fieldErrors = parsed.error.formErrors.fieldErrors;
  } else {
    name = parsed.data.name;
    success = true;
  }
}
---

<partial-boundary>
  <Card>
    {
      success && (
        <div class="bg-green-200 text-green-950 px-2 py-1 text-sm rounded">
          Success!
        </div>
      )
    }
    <form transition:name={`form-${id}`} method="POST" data-astro-reload>
      <EncodeProps {...Astro.props} />
      <CardHeader>
        <input type="hidden" name="type" value={id} />
        <input type="text" name="name" class="bg-background" value={name} />
        {
          fieldErrors.name && (
            <ul>
              {fieldErrors.name.map((error) => (
                <li class="bg-red-200 text-red-950 px-2 py-1 text-sm rounded">
                  {error}
                </li>
              ))}
            </ul>
          )
        }
        <CardContent>
          <p>0 sounds</p>
        </CardContent>
      </CardHeader>
    </form>
  </Card>
</partial-boundary>

<script>
  import {
    navigate,
    supportsViewTransitions,
    transitionEnabledOnThisPage,
  } from "astro:transitions/client";

  class PartialBoundary extends HTMLElement {
    constructor() {
      super();
    }
    connectedCallback() {
      const forms = this.querySelectorAll("form");
      forms.forEach((form) => {
        form.addEventListener("submit", (e) => this.submitCallback(e));
      });
    }

    private submitCallback(event: SubmitEvent) {
      event.preventDefault();
      const formData = new FormData(event.target as HTMLFormElement);
      fetch("/boards/SoundForm", {
        method: "POST",
        body: formData,
      }).then(async (response) => {
        if (!response.ok) {
          return navigate(window.location.pathname, { formData });
        }
        const htmlString = await response.text();
        const html = new DOMParser().parseFromString(htmlString, "text/html");
        const incoming = html.querySelector("partial-boundary");
        if (!incoming) {
          return navigate(window.location.pathname, { formData });
        }

        if (transitionEnabledOnThisPage() && supportsViewTransitions) {
          // @ts-expect-error
          document.startViewTransition(() => this.replaceWith(incoming));
        } else {
          this.replaceWith(incoming);
        }
      });
    }
  }

  customElements.define("partial-boundary", PartialBoundary);
</script>
